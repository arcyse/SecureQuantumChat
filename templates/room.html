{% extends "base.html" %}
{% block content %}
<div class="chat-container">
    <!-- Sidebar -->
    <div class="sidebar">
        <div class="sidebar-header">
            <h3>Members</h3>
            <span class="user-count" id="user-count">0</span>
        </div>
        <div class="user-list-wrapper">
            <ul id="user-list" class="user-list"></ul>
        </div>
        <div class="sidebar-footer">
            <button class="btn-secondary" id="exit-btn" onclick="leaveRoom()">
                <span>‚Üê</span> Leave Room
            </button>
        </div>
    </div>

    <!-- Main Chat Area -->
    <div class="chat-main">
        <!-- Header -->
        <div class="chat-header">
            <div class="room-info">
                <span class="room-label">#</span>
                <h2 class="room-name">{{ code }}</h2>
            </div>
            <div class="header-actions">
                <button class="btn-icon" id="debug-toggle-btn" onclick="toggleDebugConsole()" title="QKD Debug Console">
                    <span>üîç</span>
                </button>
                <button class="btn-danger" id="terminate-btn" onclick="confirmTermination()">
                    Terminate
                </button>
            </div>
        </div>

        <!-- Messages Area -->
        <div class="messages" id="messages"></div>

        <!-- Input Area -->
        <div class="message-input-container">
            <div class="input-wrapper">
                <input 
                    type="text" 
                    placeholder="Message #{{ code }}" 
                    name="message" 
                    id="message"
                    autocomplete="off"
                >
                <button class="btn-send" id="send-btn" onClick="sendMessage()">
                    <span>‚û§</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Debug Console Panel -->
    <div class="debug-console" id="debug-console">
        <div class="debug-header">
            <h3>üîê QKD Protocol Debug</h3>
            <button class="debug-close" onclick="toggleDebugConsole()">‚úï</button>
        </div>
        <div class="debug-content" id="debug-content">
            <div class="debug-log">
                <p class="debug-info">Waiting for QKD protocol to start...</p>
            </div>
        </div>
        <div class="debug-footer">
            <button onclick="clearDebugLog()">Clear</button>
            <button onclick="downloadDebugLog()">Download</button>
        </div>
    </div>
</div>

<!-- Scroll to Top Button -->
<button id="scroll-to-top-btn" class="scroll-top-btn" onclick="scrollToTop()">‚Üë</button>

<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js" integrity="sha512-E8QSvWZ0eCLGk4km3hxSsNmGWbLtSCSUcewDQPQWZF6pEU8GlT8a5fF32wOl1i8ftdMhssTrF/OhyGWwonTcXA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify@2.3.4/dist/purify.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<script type="text/javascript">
    console.log("=== Room initialized ===");
    var socketio = io();
    
    const messages = document.getElementById("messages");
    let messageInput = document.getElementById("message");
    const userList = document.getElementById("user-list");
    const userCount = document.getElementById("user-count");
    const terminateBtn = document.getElementById("terminate-btn");
    const scrollToTopBtn = document.getElementById("scroll-to-top-btn");
    const debugConsole = document.getElementById("debug-console");
    const debugContent = document.getElementById("debug-content");

    var key = 0;
    let debugLogs = [];

    // ===== DEBUG CONSOLE FUNCTIONS =====
    const toggleDebugConsole = () => {
        debugConsole.classList.toggle('active');
    };

    const addDebugLog = (message, type = 'info') => {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = `[${timestamp}] ${message}`;
        debugLogs.push(logEntry);

        const logElement = document.createElement('p');
        logElement.className = `debug-${type}`;
        logElement.textContent = logEntry;
        
        debugContent.querySelector('.debug-log').appendChild(logElement);
        debugContent.scrollTop = debugContent.scrollHeight;
    };

    const clearDebugLog = () => {
        debugLogs = [];
        debugContent.querySelector('.debug-log').innerHTML = '<p class="debug-info">Debug log cleared.</p>';
    };

    const downloadDebugLog = () => {
        const logText = debugLogs.join('\n');
        const blob = new Blob([logText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `qkd-debug-${new Date().toISOString()}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };

    // ===== UTILITY FUNCTIONS =====
    const stringToColor = (str) => {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = str.charCodeAt(i) + ((hash << 5) - hash);
        }
        let color = '#';
        for (let i = 0; i < 3; i++) {
            const value = (hash >> (i * 8)) & 0xFF;
            color += ('00' + value.toString(16)).substr(-2);
        }
        return color;
    };

    const formatTimestamp = (date) => {
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        return `${hours}:${minutes}`;
    };

    // ===== MESSAGE INPUT HANDLING =====
    messageInput.addEventListener("keydown", function(event) {
        if (event.key === "Enter" && event.shiftKey) {
            if (messageInput.tagName.toLowerCase() === 'input') {
                const textarea = document.createElement('textarea');
                textarea.id = messageInput.id;
                textarea.name = messageInput.name;
                textarea.placeholder = messageInput.placeholder;
                textarea.value = messageInput.value;
                textarea.rows = 1;
                textarea.className = messageInput.className;
                messageInput.parentNode.replaceChild(textarea, messageInput);
                messageInput = textarea;
                messageInput.focus();
                messageInput.setSelectionRange(event.target.selectionStart, event.target.selectionEnd);
            }
            const start = this.selectionStart;
            const end = this.selectionEnd;
            this.value = this.value.substring(0, start) + "\n" + this.value.substring(end);
            this.selectionStart = this.selectionEnd = start + 1;
            event.preventDefault();
        } else if (event.key === "Enter" && !event.shiftKey) {
            event.preventDefault();
            sendMessage();
        }
    });

    const sendMessage = () => {
        const message = messageInput.value.trim();
        if (message === "") return;

        addDebugLog(`Encrypting message with XOR cipher...`, 'info');
        const asciiKey = binaryToAscii(key);
        const encrypted = xorEncrypt(message, asciiKey);
        addDebugLog(`Message encrypted (${encrypted.length} bytes)`, 'success');
        
        socketio.emit("message", { message: encrypted });
        messageInput.value = "";
        
        if (messageInput.tagName.toLowerCase() === 'textarea') {
            const input = document.createElement('input');
            input.id = messageInput.id;
            input.name = messageInput.name;
            input.placeholder = messageInput.placeholder;
            input.className = messageInput.className;
            input.autocomplete = "off";
            messageInput.parentNode.replaceChild(input, messageInput);
            messageInput = input;
            messageInput.addEventListener("keydown", arguments.callee);
        }
    };

    // ===== MESSAGE DISPLAY =====
    const createMessage = (name, msg) => {
        const messageElement = document.createElement('div');
        messageElement.classList.add('message');

        const messageHeader = document.createElement('div');
        messageHeader.classList.add('message-header');

        const usernameElement = document.createElement('span');
        usernameElement.classList.add('username');
        usernameElement.style.color = stringToColor(name);
        usernameElement.textContent = name;

        const timestampElement = document.createElement('span');
        timestampElement.classList.add('timestamp');
        timestampElement.textContent = formatTimestamp(new Date());

        messageHeader.appendChild(usernameElement);
        messageHeader.appendChild(timestampElement);

        const messageContent = document.createElement('div');
        messageContent.classList.add('message-content');
        const sanitizedMessage = DOMPurify.sanitize(marked.parse(msg));
        messageContent.innerHTML = sanitizedMessage;

        messageElement.appendChild(messageHeader);
        messageElement.appendChild(messageContent);

        messages.appendChild(messageElement);

        if (messages.scrollHeight - messages.scrollTop <= messages.clientHeight + 150) {
            messages.scrollTop = messages.scrollHeight;
        }
    };

    // ===== ENCRYPTION FUNCTIONS =====
    const binaryToAscii = (binaryKey) => {
        let asciiKey = '';
        for (let i = 0; i < binaryKey.length; i += 8) {
            asciiKey += String.fromCharCode(parseInt(binaryKey.substr(i, 8), 2));
        }
        return asciiKey;
    };

    const xorEncrypt = (message, key) => {
        let result = '';
        for (let i = 0; i < message.length; i++) {
            result += String.fromCharCode(message.charCodeAt(i) ^ key.charCodeAt(i % key.length));
        }
        return btoa(result);
    };

    // ===== SOCKET EVENT HANDLERS =====
    socketio.on("message", (data) => {
        addDebugLog(`Received encrypted message from ${data.name}`, 'info');
        createMessage(data.name, data.message);
    });

    socketio.on("key", (data) => {
        key = data;
        addDebugLog(`‚úÖ QKD Complete! Key: ${data.substring(0, 32)}... (${data.length} bits)`, 'success');
    });

    socketio.on("qkd_debug", (data) => {
        addDebugLog(data.message, data.type || 'info');
    });

    socketio.on("connect", () => {
        addDebugLog(`Connected. Socket ID: ${socketio.id}`, 'success');
        addDebugLog(`Starting BB84 QKD Protocol...`, 'info');
    });

    socketio.on("disconnect", (reason) => {
        addDebugLog(`Disconnected: ${reason}`, 'warning');
    });

    socketio.on("connect_error", (error) => {
        addDebugLog(`Connection error: ${error.message}`, 'error');
    });

    // ===== ROOM MANAGEMENT =====
    const showTerminateButton = (creator) => {
        const currentUser = sessionStorage.getItem("name");
        if (currentUser === creator) {
            terminateBtn.style.display = "block";
        } else {
            terminateBtn.style.display = "none";
        }
    };

    const confirmTermination = () => {
        if (confirm("Are you sure you want to terminate the room?")) {
            socketio.emit("terminateRoom");
        }
    };

    socketio.on("roomTerminated", (data) => {
        alert(`Room ${data.code} has been terminated.`);
        window.location.href = "/";
    });

    const leaveRoom = () => {
        if (confirm("Are you sure you want to leave?")) {
            socketio.emit("leaveRoom");
            window.location.href = "/";
        }
    };

    const updateUserList = (users, creator) => {
        userList.innerHTML = '';
        users.forEach(user => {
            const li = document.createElement('li');
            li.classList.add('user-item');
            
            const userDot = document.createElement('span');
            userDot.classList.add('user-dot');
            
            const userName = document.createElement('span');
            userName.textContent = user;
            
            if (user === creator) {
                const crown = document.createElement('span');
                crown.classList.add('creator-badge');
                crown.textContent = 'üëë';
                li.appendChild(crown);
            }
            
            li.appendChild(userDot);
            li.appendChild(userName);
            userList.appendChild(li);
        });
        userCount.textContent = users.length;
        setTimeout(() => showTerminateButton(creator), 100);
    };

    socketio.on("updateUserList", (data) => {
        sessionStorage.setItem("creator", data.creator);
        updateUserList(data.users, data.creator);
    });

    socketio.emit("requestUserList");

    socketio.on("setUserName", (data) => {
        sessionStorage.setItem("name", data.name);
    });

    // ===== SCROLL FUNCTIONS =====
    const scrollToTop = () => {
        messages.scrollTop = 0;
    };

    let lastScrollTop = 0;
    messages.addEventListener('scroll', () => {
        const currentScrollTop = messages.scrollTop;
        if (currentScrollTop < lastScrollTop) {
            scrollToTopBtn.style.display = 'block';
        } else {
            scrollToTopBtn.style.display = 'none';
        }
        lastScrollTop = currentScrollTop;
    });

    scrollToTopBtn.addEventListener('mouseenter', () => {
        scrollToTopBtn.style.display = 'block';
    });

    scrollToTopBtn.addEventListener('mouseleave', () => {
        scrollToTopBtn.style.display = 'none';
    });
</script>
{% endblock %}
